# Особенности использования строкового типа данных. Массивы строк

В Си **нет строкового типа данных**. Строка — это просто **массив символов `char`**, где конец строки отмечается **нуль-терминатором** (`'\0'` — символ с кодом 0).

```c
char str[10] = "Hello"; // На самом деле: {'H','e','l','l','o','\0',?,?,?,?}
```
Важно: `"Hello"` занимает 6 байт, а не 5 (из-за `\0`).

---

### **Ключевые особенности Си-строк**

1.  **Изменяемость (в отличие от Java/Python).** Строку можно менять посимвольно:
    ```c
    char s[] = "Hello";
    s[0] = 'J'; // Теперь "Jello" — прямо в том же массиве.
    ```

2.  **Риск переполнения буфера — главная опасность.**
    ```c
    char buf[10];
    scanf("%s", buf); // Если ввести больше 9 символов — КАТАСТРОФА (undefined behavior, уязвимость).
    ```
    **Всегда** используйте функции с ограничением длины: `fgets(buf, sizeof(buf), stdin)`, `strncpy`, `snprintf`.

3.  **Сравнение строк:** `str1 == str2` сравнивает **адреса массивов**, а не содержимое!
    ```c
    char *a = "hello";
    char *b = "hello";
    // a == b может быть как true, так и false (зависит от компилятора)
    ```
    **Правильно:** `strcmp(str1, str2) == 0` (возвращает 0 при равенстве).

4.  **Конкатенация (слияние):** `strcat(dest, src)` **не проверяет** размер `dest`. Убьётся.
    **Безопасно:** `strncat(dest, src, sizeof(dest)-strlen(dest)-1)` или `snprintf`.

5.  **Длина строки:** `strlen(s)` ищет `\0`. Сложность O(n). Не вызывайте в цикле без необходимости.
    ```c
    for (int i = 0; i < strlen(s); i++) { ... } // УЖАС: strlen на каждой итерации
    ```

6.  **"Строковые литералы" (`char* p = "text"`) — неизменяемы.** Попытка изменить `p[0]='X'` — UB (чаще всего падение). Если нужно менять — копируйте в массив.

---

### **Массивы строк в Си**

Это **массив массивов `char`** (двумерный символьный массив) или **массив указателей `char*`**.

#### **Вариант 1: Фиксированные строки фиксированной длины (статика)**
```c
char strings[3][20] = { "Hello", "World", "C" };
// Память: 3 * 20 = 60 байт всегда, даже если строки короткие.
// Можно менять: strings[0][0] = 'h';
```

#### **Вариант 2: Массив указателей (гибко, экономит память)**
```c
char *strings[] = { "Hello", "World", "C" };
// Массив из 3 указателей. Сами строки — где-то в памяти (чаще в read-only сегменте).
// strings[0][0] = 'h'; // Опасность! Строки-литералы могут быть неизменяемы.
char *dynamic[] = { malloc(10), malloc(20) }; // Динамические строки
```

#### **Типичные операции с массивом строк:**
```c
// Аргументы командной строки — классический пример массива строк
int main(int argc, char *argv[]) { // argv — это char* argv[]
    for (int i = 0; i < argc; i++) {
        printf("%d: %s\n", i, argv[i]);
    }
}

// Сортировка массива строк (указателей) — быстро, меняются только указатели
#include <stdlib.h>
#include <string.h>
int cmp(const void *a, const void *b) {
    return strcmp(*(const char**)a, *(const char**)b);
}
qsort(strings, count, sizeof(char*), cmp);
```

---

### **Жёсткие правила для Си**

1.  **Всегда следите за размером буфера.** Переполнение = крах и дыра в безопасности.
2.  **Помните про `\0`.** Без него большинство функций (`printf`, `strcpy`) пойдут читать память до случайного нуля (или упадут).
3.  **Не сравнивайте строки через `==`.** Только `strcmp()`.
4.  **Для изменяемых строк используйте массивы `char s[N]`.** Для строк-констант — `const char*`.
5.  **Выделяйте память:** Если строка должна жить после выхода из функции — `malloc`/`strdup`. Не возвращайте указатель на локальный массив.
6.  **Освобождайте память:** Для каждой `malloc`/`strdup` должен быть `free`.

**Си — это про полный контроль и полную ответственность.** Строки здесь — самый опасный инструмент.