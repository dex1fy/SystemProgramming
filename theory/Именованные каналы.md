## Именованные каналы (в Windows и Linux). Назначение и использование.

**Именованные каналы (named pipes) — это "труба с адресом" для общения любых программ.**

---

### **Что это:**

**Постоянная труба с именем**, через которую могут общаться **любые программы**, даже не родственные.

```
Программа А → [труба "мой_канал"] → Программа Б
                (любая другая программа тоже может подключиться)
```

---

### **Чем отличается от анонимных каналов:**

| **Анонимные каналы** | **Именованные каналы** |
|----------------------|------------------------|
| Только родственные программы | Любые программы |
| Исчезают после закрытия | Существуют пока не удалены |
| Нет имени | Есть имя (как у файла) |
| В памяти | Видны в файловой системе |

---

### **В Linux (FIFO - First In First Out):**

#### **Создание из командной строки:**
```bash
mkfifo моя_труба  # Создал трубу с именем "моя_труба"
```

**Выглядит как файл:**
```bash
$ ls -l моя_труба
prw-r--r-- 1 user group 0 Jan 1 12:00 моя_труба
# ↑ Буква 'p' = pipe (труба)
```

#### **Пример использования:**
```bash
# Терминал 1: пишет в трубу
echo "Привет" > моя_труба
# (зависнет, пока кто-то не прочтёт)

# Терминал 2: читает из трубы
cat < моя_труба
# Выведет: Привет
```

#### **В программе на C:**
```c
#include <fcntl.h>
#include <unistd.h>

// Программа 1: создаёт и пишет
mkfifo("моя_труба", 0666);
int fd = open("моя_труба", O_WRONLY);
write(fd, "Привет", 6);

// Программа 2 (другая, даже другой пользователь): читает
int fd = open("моя_труба", O_RDONLY);
char buf[100];
read(fd, buf, 100);
```

---

### **В Windows:**

#### **Создание сервера (слушает подключения):**
```c
// Сервер создаёт канал
HANDLE hPipe = CreateNamedPipe(
    "\\\\.\\pipe\\МойКанал",  // Имя: \\.\pipe\МойКанал
    PIPE_ACCESS_DUPLEX,        // Двусторонний
    PIPE_TYPE_BYTE,            // Просто байты
    1,                         // Одно подключение
    4096, 4096, 0, NULL);      // Размеры, таймауты

// Ждёт клиента
ConnectNamedPipe(hPipe, NULL);

// Обменивается данными
WriteFile(hPipe, "Привет", 12, &bytes, NULL);
```

#### **Клиент (подключается):**
```c
// Просто подключается к существующему
HANDLE hPipe = CreateFile(
    "\\\\.\\pipe\\МойКанал",
    GENERIC_READ | GENERIC_WRITE,
    0, NULL, OPEN_EXISTING, 0, NULL);

// Читает
ReadFile(hPipe, buffer, 100, &bytes, NULL);
```

**Имя в Windows:** `\\.\pipe\имя_канала`

---

### **Зачем нужны именованные каналы:**

1. **Общение между разными программами** (даже от разных разработчиков)
2. **Клиент-серверные приложения** (сервер ждёт, клиенты подключаются)
3. **Замена сокетам** для общения на одном компьютере
4. **Постоянные каналы** которые не исчезают после закрытия программ

---

### **Примеры использования:**

#### **Пример 1: Чат между программами**
```bash
# Пользователь 1:
echo "Привет!" > /tmp/чат

# Пользователь 2 (в другом окне):
cat /tmp/чат  # Увидит "Привет!"
```

#### **Пример 2: Сервис запросов**
```
Веб-сервер → [канал "запросы"] → Обработчик
           ← [канал "ответы"] ←
```

#### **Пример 3: Логирование в реальном времени**
```bash
# Программа пишет логи:
my_program 2>&1 > /tmp/логи

# Админ читает в реальном времени:
tail -f /tmp/логи
```

---

### **Ключевые свойства:**

1. **Блокирующие операции** — чтение ждёт пока появится запись и наоборот
2. **Данные в порядке очереди** (FIFO) — первый зашёл, первый вышел
3. **Могут быть двусторонними** (Windows) или однонаправленными (Linux)
4. **Безопасность** — можно настраивать права доступа (как у файлов)

---

### **Когда использовать:**

✅ **Да, именованные каналы:**
- Нужно чтобы разные программы общались
- Клиент-сервер на одном компьютере
- Простая альтернатива сокетам

❌ **Нет, лучше сокеты или файлы:**
- Общение между компьютерами (нужны сокеты)
- Большие объёмы данных (лучше файлы)
- Нужна высокая производительность

---

**Итог:** Именованные каналы — как почтовый ящик с адресом. Любой может положить записку, любой может забрать. А анонимные каналы — как передача записки из рук в руки между двумя людьми в одной комнате.