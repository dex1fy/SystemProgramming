## Функции для работы с файлами WinAPI. Синхронный и асинхронный доступ к файлу

**WinAPI функции для файлов — продвинутые версии fopen/fread.**
**Функции WinAPI для работы с файлами — "продвинутые инструменты" Windows.**

---

### **Основные функции WinAPI для файлов:**

#### **1. `CreateFile()` — открыть или создать файл**
```c
HANDLE CreateFile(
    LPCSTR имя_файла,          // "C:\\file.txt"
    DWORD доступ,              // Что делать: читать, писать
    DWORD разделение,          // Как другие могут использовать
    LPSECURITY_ATTRIBUTES аттрибуты, // Безопасность
    DWORD создание,            // Открыть существующий/создать новый
    DWORD флаги,               // Синхронный/асинхронный, кэширование
    HANDLE шаблон              // Редко используется
);
```

**Пример открытия файла:**
```c
HANDLE hFile = CreateFile(
    "C:\\data.txt",           // Имя файла
    GENERIC_READ | GENERIC_WRITE, // Читать и писать
    0,                        // Не разделять с другими
    NULL,                     // Безопасность по умолчанию
    OPEN_EXISTING,            // Открыть существующий
    FILE_ATTRIBUTE_NORMAL,    // Обычный файл
    NULL
);

if (hFile == INVALID_HANDLE_VALUE) {
    // Ошибка!
}
```

#### **2. `ReadFile()` — чтение из файла**
```c
BOOL ReadFile(
    HANDLE файл,              // Дескриптор от CreateFile
    LPVOID буфер,             // Куда читать
    DWORD сколько_читать,     // Сколько байт прочитать
    LPDWORD сколько_прочитано,// Сколько реально прочитали
    LPOVERLAPPED перекрытие   // Для асинхронного доступа
);
```

#### **3. `WriteFile()` — запись в файл**
```c
BOOL WriteFile(
    HANDLE файл,              // Дескриптор от CreateFile
    LPCVOID данные,           // Что писать
    DWORD сколько_писать,     // Сколько байт
    LPDWORD сколько_записано, // Сколько реально записали
    LPOVERLAPPED перекрытие   // Для асинхронного
);
```

#### **4. `CloseHandle()` — закрыть файл**
```c
CloseHandle(hFile);  // ОБЯЗАТЕЛЬНО закрывать!
```


```c
HANDLE hFile = CreateFile("file.txt", GENERIC_READ, ...);
ReadFile(hFile, buffer, size, &bytesRead, NULL);
CloseHandle(hFile);
```

---

### **Синхронный доступ (простой):**

**Программа ЖДЁТ** пока файл прочтётся.

```c
ReadFile(hFile, buffer, 100, &bytesRead, NULL);
// ↑ Программа ЗАВИСАЕТ здесь, пока не прочитает 100 байт
// Потом продолжает
```

**Плюсы:** Просто.  
**Минусы:** Программа "тормозит" на время чтения.

---

### **Асинхронный доступ (сложнее, но эффективнее):**

**Программа НЕ ждёт**, читает в фоне.

```c
// 1. Открыть с флагом:
CreateFile(..., FILE_FLAG_OVERLAPPED, ...);

// 2. Создать структуру для отслеживания
OVERLAPPED ov = {0};
ov.hEvent = CreateEvent(...);  // Событие "готово"

// 3. Начать чтение (не ждать!)
ReadFile(hFile, buffer, 100, NULL, &ov);
// ↑ Сразу возвращает управление

// 4. Делать другие дела...
// 5. Когда нужно, проверить: прочиталось?
WaitForSingleObject(ov.hEvent, 1000);  // Ждать до 1 секунды
```

**Плюсы:** Программа не блокируется, может делать другое.  
**Минусы:** Сложнее писать.

---

### **Когда что использовать:**

- **Синхронно:** Маленькие файлы, простые программы
- **Асинхронно:** Большие файлы, интерфейс должен оставаться отзывчивым, серверы

---

**Пример жизни:**  
**Синхронно** — как стоять у микроволновки и ждать пока еда нагреется.  
**Асинхронно** — как поставить разогреваться и пойти смотреть телевизор, а когда готово — микроволновка "пикнет".

