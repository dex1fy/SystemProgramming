## Указатель на функцию. Назначение и примеры использования.

**Указатель на функцию — это "сохранённая команда", которую можно выполнить позже.**

---

### **Что это:**
Переменная, которая хранит **не данные, а функцию**. Как номер телефона, по которому можно позвонить.

```c
// Объявление:
возвращаемый_тип (*имя_указателя)(параметры);

// Пример:
int (*operation)(int, int);  // Указатель на функцию, 
                           // которая берёт 2 int и возвращает int
```

---

### **Зачем нужен?**

#### **1. Чтобы выбирать функцию во время работы программы**
```c
// Вместо:
if (выбор == 1) результат = сложить(a, b);
else if (выбор == 2) результат = умножить(a, b);

// Можно:
int (*функция)(int, int);
if (выбор == 1) функция = сложить;
else функция = умножить;

результат = функция(a, b);  // Вызываем выбранную функцию
```

#### **2. Чтобы передать функцию в другую функцию**
```c
// Функция обработки массива
void обработать_массив(int arr[], int size, int (*действие)(int)) {
    for (int i = 0; i < size; i++) {
        arr[i] = действие(arr[i]);  // Применяем переданное действие
    }
}

// Можно передать разные функции:
int удвоить(int x) { return x * 2; }
int квадрат(int x) { return x * x; }

обработать_массив(arr, 10, удвоить);   // Все числа ×2
обработать_массив(arr, 10, квадрат);   // Все числа²
```

---

### **Пример 1: Калькулятор**
```c
#include <stdio.h>

// Функции-операции
int плюс(int a, int b) { return a + b; }
int минус(int a, int b) { return a - b; }

int main() {
    int x = 10, y = 5;
    
    // Сохраняем функцию в указатель
    int (*операция)(int, int);
    
    операция = плюс;
    printf("%d + %d = %d\n", x, y, операция(x, y));
    
    операция = минус;
    printf("%d - %d = %d\n", x, y, операция(x, y));
    
    return 0;
}
```

### **Пример 2: Разные способы обработки данных**
```c
#include <stdio.h>

// Типы обработки
void показать(int x) { printf("%d ", x); }
void показать_квадрат(int x) { printf("%d ", x * x); }

// Общая функция обхода
void обойти_массив(int arr[], int size, void (*действие)(int)) {
    for (int i = 0; i < size; i++) {
        действие(arr[i]);  // Вызываем переданную функцию
    }
    printf("\n");
}

int main() {
    int числа[] = {1, 2, 3, 4, 5};
    
    обойти_массив(числа, 5, показать);        // Вывод: 1 2 3 4 5
    обойти_массив(числа, 5, показать_квадрат); // Вывод: 1 4 9 16 25
    
    return 0;
}
```

---

### **Где это используется в реальности:**

#### **1. Обработчики кнопок в программах**
```c
// При нажатии кнопки "Сохранить":
нажатие_кнопки(&кнопка_сохранить, функция_сохранения);
```

#### **2. Сортировка с разными правилами**
```c
// Одна функция сортировки, но можно задать:
// - сортировать по возрастанию
// - сортировать по убыванию  
// - сортировать по алфавиту
```

#### **3. Игры: разные действия для персонажа**
```c
// Одна функция "действие", но можно подставить:
// - прыжок
// - атака  
// - защита
```

---

### **Как это работает шаг за шагом:**

```c
// 1. Объявляем функцию
int сложить(int a, int b) { return a + b; }

// 2. Создаём указатель на такую функцию
int (*указ)(int, int);

// 3. Присваиваем адрес функции
указ = сложить;  // Теперь указ "знает", где сложить()

// 4. Вызываем через указатель
int результат = указ(3, 4);  // = 7
```

---

### **Простейшая аналогия:**

**Обычная функция** = прямое обращение: "Вася, сделай это"  
**Указатель на функцию** = записка: "позвони по номеру... и скажи сделать это"

---

### **Основные правила:**

1. **Сигнатура должна совпадать** — указатель может хранить только функции с теми же параметрами и возвращаемым типом
2. **Проверяй на NULL** перед вызовом
3. **Имя функции = её адрес** — можно присваивать без &

```c
// Правильно:
указатель = функция_сложения;

// Вызывать можно двумя способами:
результат = указатель(5, 3);    // Просто
результат = (*указатель)(5, 3); // С явным разыменованием
```

---

### **Итог одной строкой:**

**Указатель на функцию позволяет хранить и передавать "команды" как обычные переменные, делая программу гибче.**