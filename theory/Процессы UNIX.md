## Создание процессов в UNIX-подобных операционных системах

**Создание процессов в UNIX — клонирование программы.**

---

### **`fork()` — разделение на два одинаковых**

```c
pid_t pid = fork();  // Создал копию себя
```

**После `fork()` есть два одинаковых процесса:**

- **Родительский** — продолжает выполнение
- **Дочерний** — начинает с того же места

**Как отличить:**
```c
if (pid == 0) {
    // Я ребёнок
} else {
    // Я родитель, pid = ID ребёнка
}
```

---

### **`exec()` — замена программы**

Заменяет текущую программу на другую:

```c
execlp("ls", "ls", "-la", NULL);  // Стал программой ls
// Код после exec не выполнится (если нет ошибки)
```

---

### **Классика: `fork()` + `exec()`**

```c
if (fork() == 0) {      // 1. Создаём ребёнка
    execlp("ls", "ls", "-la", NULL);  // 2. Заменяем на ls
    exit(1);  // Если сюда попали — ошибка
} else {
    wait(NULL);  // 3. Ждём завершения ребёнка
}
```

**Так работает командная строка:** набираете `ls` → shell делает `fork()+exec()`

---

### **Пример: три ребёнка**
```c
for (int i = 1; i <= 3; i++) {
    if (fork() == 0) {
        printf("Ребёнок %d\n", i);
        exit(0);  // Ребёнок завершается
    }
}

// Родитель ждёт всех
for (int i = 1; i <= 3; i++) {
    wait(NULL);
}
```

---

### **Что наследует ребёнок:**

1. **Открытые файлы** (те же дескрипторы)
2. **Переменные окружения**
3. **Текущий каталог**
4. **Права доступа**

---

### **Три состояния ребёнка:**

1. **Работает** — делает свою задачу
2. **Зомби** — завершился, но родитель ещё не спросил результат
3. **Сирота** — родитель умер раньше

**Убрать зомби:**
```c
wait(NULL);  // "Похоронить" завершившегося ребёнка
```

---

### **Итог одной строкой:**

**`fork()` создаёт копию, `exec()` заменяет программу, `wait()` ждёт завершения.**