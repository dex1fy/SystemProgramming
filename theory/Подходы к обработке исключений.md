## Подходы к обработке исключений в программах, написанных на си

### **Ситуация: Файл может не существовать, а число может быть нулём.**

## **C# (Современный язык с исключениями)**

```csharp
try 
{
    string text = File.ReadAllText("data.txt"); // 1. Может выбросить исключение
    int number = int.Parse(text);              // 2. Может выбросить исключение
    int result = 100 / number;                 // 3. Может выбросить исключение
    
    Console.WriteLine($"Результат: {result}");
}
catch (FileNotFoundException) 
{
    Console.WriteLine("Файл не найден!");
}
catch (FormatException) 
{
    Console.WriteLine("В файле не число!");
}
catch (DivideByZeroException) 
{
    Console.WriteLine("Делить на ноль нельзя!");
}
catch (Exception ex) // Все остальные ошибки
{
    Console.WriteLine($"Неизвестная ошибка: {ex.Message}");
}
finally 
{
    Console.WriteLine("Эта часть выполнится в любом случае");
}
```

**Как это работает в C#:**
1. Код пишется **как будто всё всегда хорошо**.
2. Если происходит ошибка — выполнение **прерывается** и переходит в `catch`.
3. Не нужно после каждой строчки проверять "а не ошибка ли?".
4. Ошибки **нельзя проигнорировать** — если не поймать исключение, программа упадёт.

**Проще говоря:** C# кричит **«АЙ!»** когда что-то идёт не так, и ты должен это услышать.

---

## **Си (Ручная обработка ошибок)**

```c
#include <stdio.h>
#include <stdlib.h>

int main() 
{
    FILE* file = fopen("data.txt", "r"); // 1. Пытаемся открыть
    
    if (file == NULL) // Вручную проверяем ошибку
    { 
        printf("Файл не найден!\n");
        return 1; // Выходим с кодом ошибки
    }
    
    char buffer[100];
    if (fgets(buffer, sizeof(buffer), file) == NULL) // 2. Пытаемся прочитать
    {
        printf("Не могу прочитать файл!\n");
        fclose(file); // Вручную закрываем файл
        return 1;
    }
    
    fclose(file); // Вручную закрываем файл
    
    int number = atoi(buffer); // 3. Пытаемся конвертировать
    if (number == 0 && buffer[0] != '0') // atoi возвращает 0 при ошибке
    {
        printf("В файле не число!\n");
        return 1;
    }
    
    if (number == 0) // 4. Проверяем деление на ноль
    {
        printf("Делить на ноль нельзя!\n");
        return 1;
    }
    
    int result = 100 / number;
    printf("Результат: %d\n", result);
    
    return 0; // Успех
}
```

**Как это работает в Си:**
1. После **каждой операции** вручную проверяем: "а не ошибка ли?"
2. Если ошибка — обрабатываем её **прямо тут же**.
3. Нужно **самому** не забыть освободить ресурсы (закрыть файл).
4. Ошибку **можно проигнорировать** — если не проверить `if`, программа продолжит работать с неверными данными.

**Проще говоря:** Си молча делает работу, а ты должен **сам постоянно спрашивать** "Всё в порядке?" после каждого шага.

---

### **Простая аналогия:**

**C# (с исключениями):**
> — Сходи в магазин за хлебом.  
> *Если магазин закрыт — позвони мне.*  
> *Если хлеба нет — позвони мне.*  
> *Если сломался лифт — позвони мне.*  

Ты просто идешь в магазин, а если **любая** проблема — звонишь.

**Си (без исключений):**
> — Сходи в магазин за хлебом.  
> — Проверь, открыт ли магазин. Если нет — вернись и скажи.  
> — Проверь, есть ли хлеб. Если нет — вернись и скажи.  
> — Проверь, работает ли лифт. Если нет — вернись и скажи.  

Ты должен **после каждого шага** проверять, не случилась ли проблема, и реагировать сразу.

---

### **Главный вывод:**

- **C#:** Ошибки обрабатываются **отдельно** от основного кода. Код чистый, но нужно знать, какие исключения могут быть.
- **Си:** Ошибки обрабатываются **вместе** с основным кодом. Код громоздкий, но полностью контролируемый.

**Си** заставляет думать об ошибках после **каждой** операции. **C#** позволяет думать об ошибках один раз, в конце.


## **Кратко про подходы в Си:**

### **1. Проверка на месте (Самый простой)**
```c
FILE* f = fopen("file.txt", "r");
if (f == NULL) {
    // Сразу обработали ошибку
    return;
}
```
**Как:** После каждой операции пишем `if` и обрабатываем ошибку тут же.

---

### **2. Возврат кода ошибки (Самый популярный)**
```c
int load_file() {
    if (error1) return -1; // код ошибки
    if (error2) return -2; // другой код
    return 0; // успех
}

// Где-то в коде:
int result = load_file();
if (result != 0) {
    // Упс, ошибка
}
```
**Как:** Все функции возвращают числа: `0` = ок, `не 0` = ошибка.

---

### **3. Передача ошибки в параметре**
```c
int compute(int a, int b, int* result) {
    if (b == 0) return 0; // 0 = ошибка
    *result = a / b;
    return 1; // 1 = успех
}

// Использование:
int res;
if (!compute(10, 0, &res)) {
    // Ошибка!
}
```
**Как:** Функция возвращает `1/0` (успех/провал), а результат — через указатель.

---

### **4. Структура-результат**
```c
typedef struct {
    int ok; // 1 если хорошо
    int value; // результат
    char error[100]; // текст ошибки
} Result;

Result divide(int a, int b) {
    Result r = {0};
    if (b == 0) {
        strcpy(r.error, "Деление на 0");
        return r; // r.ok = 0
    }
    r.ok = 1;
    r.value = a / b;
    return r;
}
```
**Как:** Функция всегда возвращает структуру, где есть поле "успешно ли".

---

### **5. Глобальная переменная ошибки**
```c
char last_error[100];

void risky() {
    if (problem) {
        strcpy(last_error, "Что-то сломалось");
        return;
    }
}

// Где-то:
risky();
if (strlen(last_error) > 0) {
    // Была ошибка
}
```
**Как:** Ошибки пишутся в глобальную переменную, которую можно проверить где угодно.

---
### **Проще всего запомнить так:**

**В Си у вас есть 5 способов сказать "ой, ошибка":**
1. **Крикнуть тут же** — обработать сразу после проблемы
2. **Сказать номер ошибки** — вернуть код ошибки
3. **Сказать "не получилось" + результат отдельно** — `return 0` и указатель
4. **Отдать записку** — структура с полем "ок/не ок"
5. **Оставить записку на столе** — глобальная переменная

**Нет** способа крикнуть "ой!" и чтобы ошибка сама всплыла наверх как в C#. Всё делается руками.