## Сигналы. Особенности создания и использования сигналов.

## **СИГНАЛЫ — это как "толчки в бок" для программы**

**Представь:** Твоя программа работает. Внезапно кто-то **толкает её в бок** (это сигнал). Программа должна **отреагировать** на этот толчок.

---

## **1. Что такое сигнал?**

**Сигнал** — это короткое сообщение от ядра ОС или другой программы твоему процессу: "СРОЧНО сделай что-то!"

**Примеры из жизни:**
- `SIGINT` (Ctrl+C) — "Прервись!"
- `SIGKILL` (убить процесс) — "Умри немедленно!"
- `SIGSEGV` (ошибка памяти) — "Ты сломал память!"

---

## **2. Как создаются/отправляются сигналы?**

### **а) С клавиатуры (ты нажимаешь клавиши):**
```bash
Ctrl+C    -> SIGINT   (прервать)
Ctrl+\    -> SIGQUIT  (выйти с дампом)
Ctrl+Z    -> SIGTSTP  (остановить)
```

### **б) Из командной строки:**
```bash
kill -9 PID      # SIGKILL (убить наверняка)
kill -15 PID     # SIGTERM (вежливо попросить завершиться)
```

### **в) Из другой программы (Си):**
```c
kill(pid, SIGUSR1);  // Отправить сигнал процессу с номером PID
```

### **г) Автоматически от ядра:**
- Деление на ноль -> `SIGFPE`
- Обращение к "чужой" памяти -> `SIGSEGV`
- Дочерний процесс завершился -> `SIGCHLD`

---

## **3. Особенности сигналов (главное для экзамена!)**

### **1. Сигнал — это НЕ функция и НЕ поток**
- Это **асинхронное событие** (может прийти в любой момент).
- Сигнал **прерывает** нормальное выполнение программы.

### **2. Три способа реакции на сигнал:**
```c
// 1. Игнорировать (не для всех сигналов можно!)
signal(SIGINT, SIG_IGN);

// 2. Стандартная реакция (по умолчанию)
signal(SIGINT, SIG_DFL);  // Ctrl+C убьет программу

// 3. Своя функция-обработчик
void my_handler(int sig) {
    printf("Поймал сигнал %d!\n", sig);
}
signal(SIGINT, my_handler);
```

### **3. Важные сигналы (запомни названия):**

| Сигнал    | Номер | Что делает по умолчанию | Можно перехватить? |
|-----------|-------|------------------------|-------------------|
| **SIGINT**  | 2     | Завершение (Ctrl+C)    | Да                |
| **SIGKILL** | 9     | Немедленное убийство   | **НЕТ!**          |
| **SIGTERM** | 15    | Вежливое завершение    | Да                |
| **SIGSEGV** | 11    | Ошибка сегментации     | Да (но опасно)    |
| **SIGUSR1** | 10    | Пользовательский 1     | Да                |
| **SIGUSR2** | 12    | Пользовательский 2     | Да                |
| **SIGSTOP** | 19    | Приостановка (Ctrl+Z)  | **НЕТ!**          |
| **SIGCHLD** | 17    | Дочерний умер          | Да                |

**Запомни:** SIGKILL и SIGSTOP **нельзя** перехватить/игнорировать!

---

## **4. Создание своего обработчика**

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig_num) {
    printf("\nПоймал сигнал %d! Не убьюсь!\n", sig_num);
}

int main() {
    // Устанавливаем свой обработчик на Ctrl+C
    signal(SIGINT, handler);
    
    printf("PID: %d\n", getpid());
    printf("Нажми Ctrl+C...\n");
    
    while(1) {
        sleep(1);
        printf(".");
        fflush(stdout);
    }
    
    return 0;
}
```

**Что будет:** При нажатии Ctrl+C программа не умрёт, а напечатает сообщение и продолжит работу.

---

## **5. Особенности работы**

### **1. Сигналы "теряются"**
Если пришло 10 одинаковых сигналов, программа может обработать только 1.

### **2. Очередь сигналов НЕ существует**
(В старом POSIX. В новых есть real-time сигналы с очередями)

### **3. В обработчике нельзя много делать**
Можно только:
- Установить флаг
- Изменить глобальную переменную
- Вызвать несколько безопасных функций (не `printf`, `malloc`!)

**Почему?** Потому что сигнал может прийти ВО ВРЕМЯ выполнения `printf` или `malloc` и всё сломает.

### **4. Безопасный обработчик:**
```c
volatile int flag = 0;  // volatile - чтобы компилятор не оптимизировал

void handler(int sig) {
    flag = 1;  // ТОЛЬКО так!
}

int main() {
    signal(SIGINT, handler);
    
    while(1) {
        if (flag) {  // Проверяем в основном коде
            printf("Был сигнал!\n");
            flag = 0;
            // Делаем что-то тяжелое здесь, а не в обработчике
        }
        sleep(1);
    }
}
```

---

## **6. Современный способ — sigaction()**

`signal()` — старый и ненадёжный.  лучше использовать `sigaction()`.

```c
struct sigaction sa;
sa.sa_handler = handler;  // Функция-обработчик
sigemptyset(&sa.sa_mask); // Какие сигналы блокировать на время обработки
sa.sa_flags = 0;          // Флаги

sigaction(SIGINT, &sa, NULL);  // Установить
```

**Преимущества sigaction():**
- Можно блокировать другие сигналы на время обработки
- Не сбрасывается после обработки (в отличие от signal() в некоторых системах)
- Больше контроля

---

## **Основные тезисы:**

1. **Сигнал** — асинхронное уведомление процессу
2. **Отправить:** Ctrl+C, kill, kill(), от ядра
3. **Три реакции:** игнорировать, по умолчанию, свой обработчик
4. **SIGKILL/SIGSTOP** нельзя перехватить!
5. **В обработчике** только простые действия
6. **Лучше использовать sigaction(), а не signal()**
7. **Сигналы теряются** (нет очереди)

---

**В:** "Что произойдёт, если во время выполнения обработчика сигнала придет тот же самый сигнал?"

**О:** "Поведение не определено. Может быть deadlock. Поэтому в обработчике нужно блокировать этот сигнал (через sa_mask в sigaction), а тяжелые операции делать в основном коде по флагу."

**В:** "Как завершить процесс, который перехватил все сигналы?"

**О:** "Отправить SIGKILL (kill -9), его нельзя перехватить."