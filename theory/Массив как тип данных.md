**Массив в Си — это "ряд одинаковых ящиков в памяти".**

---

### **Что такое массив?**

**Массив** — это набор одинаковых элементов, лежащих в памяти друг за другом.

```c
int numbers[5];  // 5 ящиков для int, идут подряд
```
```
Память: [ ][ ][ ][ ][ ]
        0  1  2  3  4  ← индексы
```

---

### **3 главные особенности массивов в Си:**

#### **1. Массив = указатель на первый элемент (но не совсем!)**
```c
int arr[5] = {1, 2, 3, 4, 5};
// arr автоматически преобразуется в &arr[0] в большинстве случаев
// Но sizeof(arr) даёт размер всего массива (5 * sizeof(int))
```

#### **2. Индексация с 0 (не с 1!)**
```c
int arr[3] = {10, 20, 30};
arr[0] = 10;  // Первый элемент
arr[1] = 20;  // Второй  
arr[2] = 30;  // Третий
// arr[3] = ОШИБКА! Выход за границы
```

#### **3. Размер должен быть известен на этапе компиляции (для статических)**
```c
int n = 10;
int arr[n];  // ОШИБКА в стандартном C89 (но работает в C99)
// Лучше:
#define SIZE 10
int arr[SIZE];  // Правильно
```

---

### **Как объявлять массивы:**

```c
// 1. С указанием размера
int arr1[5];  // 5 элементов, значения мусор

// 2. С инициализацией
int arr2[5] = {1, 2, 3, 4, 5};  // Все 5 заданы
int arr3[5] = {1, 2};           // Первые два: 1,2, остальные 0
int arr4[] = {1, 2, 3, 4};      // Размер автоматически 4

// 3. Двумерные (матрицы)
int matrix[3][4];  // 3 строки, 4 столбца
int mat[2][3] = {{1,2,3}, {4,5,6}};
```

---

**Массив в Си — "ряд ящиков в памяти". Элементы лежат подряд, индексы с 0.**    

### **Ключевые особенности Си:**
1. **Имя массива = указатель на первый элемент** (в большинстве случаев)
   ```c
   int arr[5];  // arr == &arr[0], но sizeof(arr) = размер всего массива
   ```

2. **Нет проверки границ** — выход за массив не ловит, портит память
   ```c
   arr[10] = 5;  // Опасно, но компилируется
   ```

3. **При передаче в функцию теряется размер**
   ```c
   void func(int arr[]) {  // Фактически int* arr
       // Нельзя узнать размер массива внутри!
   }
   // Решение: передавать размер отдельно
   void func(int arr[], int size);
   ```

4. **Массивы нельзя присваивать/сравнивать напрямую**
   ```c
   int a[3], b[3];
   b = a;          // Ошибка
   if (a == b) { } // Сравнивает адреса, не содержимое
   // Нужно копировать/сравнивать поэлементно
   ```

5. **Строка = массив char с `'\0'` в конце**
   ```c
   char s[6] = "Hello";  // 5 букв + '\0'
   ```

6. **Статические массивы требуют константный размер** (в старом Си)
   ```c
   #define N 10
   int arr[N];  // Правильно
   int n = 10;
   int arr[n];  // Ошибка в C89
   ```

### **Правила использования:**
- **Всегда передавайте размер массива** в функцию
- **Инициализируйте массивы**: `int arr[100] = {0};`
- **Для больших данных используйте динамические массивы**:
  ```c
  int* arr = malloc(n * sizeof(int));
  // ... используйте ...
  free(arr);
  ```
- **Для строк оставляйте место под `'\0'`**

**Итог:** Массивы в Си — низкоуровневые, требуют ручного управления. Нет защиты, нет встроенных операций, но полный контроль над памятью.