## Линейный односвязный список. Особенности создания и примеры использования.

**Линейный односвязный список — гибкая структура данных для динамических последовательностей.**

---

### **Основная идея:**
Каждый элемент (узел) содержит:
1. **Данные** (значение)
2. **Ссылку** на следующий элемент

```
[Данные|→] → [Данные|→] → [Данные|NULL]
```

---

### **Структура в Си:**
```c
struct Node {
    int data;           // Полезные данные
    struct Node* next;  // Ссылка на следующий узел
};
```

---

### **Почему не массив? Решаемые проблемы:**

1. **Массив фиксированного размера:**
   ```c
   int arr[100];  // А если нужно 101 элемент? Переполнение!
   ```
   
2. **Медленная вставка в середину массива:**
   ```c
   // Чтобы вставить в середину, нужно сдвигать все последующие элементы
   // Список: просто меняем 2 указателя
   ```

3. **Неэффективное использование памяти:**
   - Массив выделяет всё сразу, даже если используется частично
   - Список выделяет память только под нужные узлы

---

### **Ключевые операции:**

#### **1. Создание узла:**
```c
struct Node* create_node(int value) {
    struct Node* node = malloc(sizeof(struct Node));
    node->data = value;
    node->next = NULL;
    return node;
}
```

#### **2. Добавление в начало (O(1)):**
```c
void add_first(struct Node** head, int value) {
    struct Node* new_node = create_node(value);
    new_node->next = *head;  // Новый указывает на старую голову
    *head = new_node;        // Голова теперь новый узел
}
```

#### **3. Добавление в конец (O(n)):**
```c
void add_last(struct Node** head, int value) {
    struct Node* new_node = create_node(value);
    
    if (*head == NULL) {
        *head = new_node;
        return;
    }
    
    struct Node* current = *head;
    while (current->next != NULL) {  // Идём до последнего
        current = current->next;
    }
    current->next = new_node;
}
```

#### **4. Обход списка:**
```c
void print_list(struct Node* head) {
    struct Node* current = head;
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
}
```

#### **5. Удаление узла:**
```c
void delete_node(struct Node** head, int value) {
    struct Node* current = *head;
    struct Node* prev = NULL;
    
    while (current != NULL && current->data != value) {
        prev = current;
        current = current->next;
    }
    
    if (current != NULL) {
        if (prev == NULL) {
            *head = current->next;  // Удаляем голову
        } else {
            prev->next = current->next;  // Удаляем из середины
        }
        free(current);
    }
}
```

---

### **Практические примеры использования:**

#### **Пример 1: История браузера**
```c
struct History {
    char url[256];
    struct History* next;
};

// "Назад" = перейти к предыдущему узлу
// Новые страницы добавляются в конец
```

#### **Пример 2: Очередь печати**
```c
struct PrintJob {
    int id;
    struct PrintJob* next;
};

// Новые задания в конец, печатаем с начала
```

#### **Пример 3: Стек (LIFO)**
```c
struct Stack {
    int value;
    struct Stack* next;
};

// Добавление и удаление только с начала (быстро)
```

---

### **Преимущества:**
- **Динамический размер** — растёт по мере необходимости
- **Быстрая вставка/удаление** в начало (O(1))
- **Экономия памяти** при частичном использовании
- **Гибкость** — легко менять порядок элементов

### **Недостатки:**
- **Медленный доступ** по индексу (нужно проходить все предыдущие)
- **Дополнительная память** на указатели
- **Только однонаправленный обход** (в односвязном)
- **Сложность реализации** — легко допустить ошибку с указателями

---

### **Когда использовать:**

✅ **Да, список:**
- Неизвестно количество элементов заранее
- Частые вставки/удаления в начале/середине
- Реализация стека, очереди
- Данные часто перестраиваются

❌ **Нет, массив:**
- Известно точное количество элементов
- Нужен быстрый доступ по индексу
- Данные статичны, редко меняются
- Простая обработка всех элементов

---

### **Важные особенности:**
1. **Голова списка** — указатель на первый элемент (`head == NULL` если пуст)
2. **Хвост** — последний элемент указывает на `NULL`
3. **Память динамическая** — каждый узел через `malloc()`, не забывать `free()`
4. **Обход всегда с головы** — нельзя начать с середины

---

### **Простой пример использования:**
```c
// Создаём список: 10 → 20 → 30
struct Node* list = NULL;
add_last(&list, 10);
add_last(&list, 20);
add_last(&list, 30);

// Вставляем 15 после 10: 10 → 15 → 20 → 30
struct Node* current = list;
while (current != NULL && current->data != 10) {
    current = current->next;
}
if (current != NULL) {
    struct Node* new_node = create_node(15);
    new_node->next = current->next;
    current->next = new_node;
}

// Удаляем 20: 10 → 15 → 30
delete_node(&list, 20);
```

---

**Итог:** Односвязный список — идеальный выбор для данных, которые часто меняются и имеют переменный размер. Он даёт гибкость ценой скорости произвольного доступа и требует аккуратной работы с памятью.