Разработка программы для вычисления факториала в отдельном потоке. В программе должна быть предусмотрена валидация данных (отдельно для Windows и Linux)

Шаг 1. Для Windows создадим следующий файл main.c

``` C
#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>

long long getFact(int n) {
	long long result = 1; 
	for (int i = 1; i <= n; i++) {
		result *= i;
		if (result < 0) return -2; 
	}
	return result;
}

DWORD factCalc(LPVOID lpThreadParameter) {
	long long f = getFact(lpThreadParameter);
	if (f == -2) {
		printf("%s\n", "overflow");
	}
	else {
		printf("%d\n", f);
	}
}

int main() {
	system("chcp 1251");
	int n;
	scanf_s("%d", &n);
	if (n < 0) {
		printf("n must be > 0");
		return 0;
	}

	HANDLE threadF;
	threadF = CreateThread(0, 0, factCalc, n, 0, 0);
	WaitForSingleObject(threadF, INFINITE);
}

```

Шаг 2. Для Linux создадим следующий файл main.c

``` C
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

long long getF(int n) {
    int result = 1;
    for (size_t i = 1; i <= n; i++)
    {
        result *= i;
        if(result < 0) return -2;
    }
    return result;
}

void* CalcF(void* arg) {
    long long f = getF(arg);
    if(f == -2) {
        printf("Переполнение\n");
    }
    else {
        printf("факториал: %d\n", f);
    }
}

int main()
{
    pthread_t thread;

    printf("Введите n: ");
    int n;
    scanf("%d", &n);
    if (n < 0)
    {
        printf("n должно быть целым положительным числом\n");
        return 0;
    }

    pthread_create(&thread, 0, CalcF, n);
    pthread_join(&thread, 0);
    pthread_detach(&thread);
    return 1;
}
```