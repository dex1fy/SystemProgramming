## Получение названия клавиши с использованием функции GetKeyNameText (Windows HOOK). Название клавиши выводить в MessageBox

Шаг 1. Создать файл main.c с следующим кодом.

``` C
#include <Windows.h>

LRESULT CALLBACK HookProc(int code, WPARAM wParam, LPARAM lParam) {
	if (code >= 0 && wParam == WM_KEYDOWN) {
		PKBDLLHOOKSTRUCT pKeyboard = lParam;
		char buffer[100];
		if (GetKeyNameTextA(pKeyboard->scanCode << 16, buffer, 100) != 0){
			MessageBoxA(0, buffer, "Title", 0);
		}
	}
	else {
		CallNextHookEx(0, code, wParam, lParam);
	}
}

int main() {
	HHOOK hook = SetWindowsHookExA(WH_KEYBOARD_LL, HookProc, GetModuleHandleW(0), 0);
	if (hook != 0) {
		MSG msg;
		while (GetMessageW(&msg, 0, 0, 0)) {
			TranslateMessage(&msg);
			DispatchMessageW(&msg);
		}
		UnhookWindowsHookEx(hook);
	}
}
```



```C
#include <Windows.h>  // Главный заголовочный файл Windows API, содержит все необходимые определения

// Функция обработки хука (перехвата) клавиатуры
// CALLBACK - соглашение о вызове для callback-функций Windows
// LRESULT - тип возвращаемого значения (длинное целое)
LRESULT CALLBACK HookProc(int code, WPARAM wParam, LPARAM lParam) {
    // Проверяем: код >= 0 (нормальное событие) И тип события - нажатие клавиши (WM_KEYDOWN)
    if (code >= 0 && wParam == WM_KEYDOWN) {
        // Приводим lParam к структуре информации о нажатии клавиши
        // PKBDLLHOOKSTRUCT - указатель на структуру KBDLLHOOKSTRUCT
        PKBDLLHOOKSTRUCT pKeyboard = (PKBDLLHOOKSTRUCT)lParam;

        // Объявляем буфер для имени клавиши (массив из 100 символов на char)
        char buffer[100];  

        // Получаем текстовое имя клавиши по её скан-коду
        // pKeyboard->scanCode << 16 - сдвиг скан-кода в старшие биты (требуется для GetKeyNameTextA)
        // buffer - куда записывать имя
        // 100 - размер буфера
        if (GetKeyNameTextA(pKeyboard->scanCode << 16, buffer, 100) != 0) {
            // Показываем окно с сообщением, содержащим имя нажатой клавиши
            // 0 - хендл родительского окна (нет)
            // buffer - текст сообщения
            // "Title" - заголовок окна
            // 0 - флаги (MB_OK по умолчанию)
            MessageBoxA(0, buffer, "Title", 0);
        }
    }
    else {
        // Если это не нажатие клавиши или code < 0, передаем событие дальше по цепочке хуков
        // 0 - идентификатор хука (в данном случае не используется)
        CallNextHookEx(0, code, wParam, lParam);
    }
}

int main() {
    // Устанавливаем low-level хук на клавиатуру (WH_KEYBOARD_LL)
    // WH_KEYBOARD_LL - тип хука (низкоуровневый, перехватывает до помещения в системную очередь)
    // HookProc - наша функция-обработчик
    // GetModuleHandleW(0) - получаем хендл текущего модуля (exe-файла)
    // 0 - идентификатор потока (0 = все потоки в системе)
    HHOOK hook = SetWindowsHookExA(WH_KEYBOARD_LL, HookProc, GetModuleHandleW(0), 0);

    // Если хук успешно установлен
    if (hook != 0) {
        // Структура для хранения сообщения Windows
        MSG msg;

        // Цикл обработки сообщений Windows
        // GetMessageW извлекает сообщение из очереди потока
        // &msg - куда поместить сообщение
        // 0 - хендл окна (0 = все окна)
        // 0, 0 - фильтр по минимуму и максимуму ID сообщений
        while (GetMessageW(&msg, 0, 0, 0)) {
            // Преобразуем виртуальные клавиши в символы
            TranslateMessage(&msg);

            // Отправляем сообщение соответствующей оконной процедуре
            DispatchMessageW(&msg);
        }

        // Снимаем хук перед выходом из программы
        UnhookWindowsHookEx(hook);
    }
}

```